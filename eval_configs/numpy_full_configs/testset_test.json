{
  "name": "NumPy Demo Testset",
  "version": "1.0.0",
  "description": "Tests aligned with NumPy tasks progressing from beginner to expert",
  "tests": [
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    },
    {
      "name": "Create 2D array test",
      "version": "1.0.0",
      "description": "Test creation of a NumPy array with specified dimensions and values",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array has correct shape (3 rows, 4 columns)\nassert array.shape == (3, 4), f'Array must have shape (3, 4), but got {array.shape}'\n\n# Test that array contains integers\nassert np.issubdtype(array.dtype, np.integer), f'Array must contain integers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 100 (inclusive)\nassert np.all((array >= 0) & (array <= 100)), 'All array values must be between 0 and 100'"
    },
    {
      "name": "Calculate mean test", 
      "version": "1.0.0",
      "description": "Test calculation of the mean of a NumPy array",
      "content": "import numpy as np\n\n# Test that array variable exists\nassert 'array' in locals() or 'array' in globals(), 'Variable \"array\" must be defined'\n\n# Test that mean variable exists\nassert 'mean' in locals() or 'mean' in globals(), 'Variable \"mean\" must be defined'\n\n# Test that array is a numpy array\nassert isinstance(array, np.ndarray), 'Variable \"array\" must be a numpy array'\n\n# Test that array is 1D\nassert array.ndim == 1, f'Array must be 1-dimensional, but got {array.ndim} dimensions'\n\n# Test that array has 10 elements\nassert len(array) == 10, f'Array must have 10 elements, but got {len(array)}'\n\n# Test that array contains floating-point numbers\nassert np.issubdtype(array.dtype, np.floating), f'Array must contain floating-point numbers, but got dtype {array.dtype}'\n\n# Test that all values are between 0 and 1\nassert np.all((array >= 0) & (array <= 1)), 'All array values must be between 0 and 1'\n\n# Test that mean is calculated correctly\nexpected_mean = np.mean(array)\nassert np.isclose(mean, expected_mean), f'Mean should be {expected_mean}, but got {mean}'\n\n# Test that mean is a scalar (not an array)\nassert np.isscalar(mean), 'Mean must be a scalar value'"
    },
    {
      "name": "Array slicing test",
      "version": "1.0.0",
      "description": "Test array slicing operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sliced_array' in locals() or 'sliced_array' in globals(), 'Variable \"sliced_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(sliced_array, np.ndarray), 'Variable \"sliced_array\" must be a numpy array'\n\n# Test that original array contains values 0 to 19\nassert len(original_array) == 20, f'Original array must have 20 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(20)), f'Original array should contain values 0-19, but got {original_array}'\n\n# Test that sliced array contains every second element starting from index 1\nexpected_sliced = np.arange(20)[1::2]\nassert np.array_equal(sliced_array, expected_sliced), f'Sliced array should be {expected_sliced}, but got {sliced_array}'"
    },
    {
      "name": "Array reshaping test",
      "version": "1.0.0", 
      "description": "Test array reshaping operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'reshaped_array' in locals() or 'reshaped_array' in globals(), 'Variable \"reshaped_array\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(reshaped_array, np.ndarray), 'Variable \"reshaped_array\" must be a numpy array'\n\n# Test that original array contains 12 consecutive integers starting from 1\nassert len(original_array) == 12, f'Original array must have 12 elements, but got {len(original_array)}'\nassert np.array_equal(original_array, np.arange(1, 13)), f'Original array should contain values 1-12, but got {original_array}'\n\n# Test that reshaped array has correct shape and same data\nassert reshaped_array.shape == (3, 4), f'Reshaped array must have shape (3, 4), but got {reshaped_array.shape}'\nassert np.array_equal(reshaped_array.flatten(), original_array), 'Reshaped array must contain the same data as original array'"
    },
    {
      "name": "Element-wise operations test",
      "version": "1.0.0",
      "description": "Test element-wise mathematical operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array1' in locals() or 'array1' in globals(), 'Variable \"array1\" must be defined'\nassert 'array2' in locals() or 'array2' in globals(), 'Variable \"array2\" must be defined'\nassert 'product' in locals() or 'product' in globals(), 'Variable \"product\" must be defined'\nassert 'sum_array' in locals() or 'sum_array' in globals(), 'Variable \"sum_array\" must be defined'\n\n# Test that all are numpy arrays\nassert isinstance(array1, np.ndarray), 'Variable \"array1\" must be a numpy array'\nassert isinstance(array2, np.ndarray), 'Variable \"array2\" must be a numpy array'\nassert isinstance(product, np.ndarray), 'Variable \"product\" must be a numpy array'\nassert isinstance(sum_array, np.ndarray), 'Variable \"sum_array\" must be a numpy array'\n\n# Test array shapes\nassert array1.shape == (2, 3), f'Array1 must have shape (2, 3), but got {array1.shape}'\nassert array2.shape == (2, 3), f'Array2 must have shape (2, 3), but got {array2.shape}'\n\n# Test value ranges\nassert np.all((array1 >= 1) & (array1 <= 10)), 'Array1 values must be between 1 and 10'\nassert np.all((array2 >= 1) & (array2 <= 10)), 'Array2 values must be between 1 and 10'\n\n# Test that operations are correct\nassert np.array_equal(product, array1 * array2), 'Product should be element-wise multiplication of array1 and array2'\nassert np.array_equal(sum_array, array1 + array2), 'Sum_array should be element-wise addition of array1 and array2'"
    },
    {
      "name": "Boolean indexing test",
      "version": "1.0.0",
      "description": "Test boolean indexing for filtering arrays",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'positive_values' in locals() or 'positive_values' in globals(), 'Variable \"positive_values\" must be defined'\n\n# Test that both are numpy arrays\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert isinstance(positive_values, np.ndarray), 'Variable \"positive_values\" must be a numpy array'\n\n# Test original array properties\nassert len(original_array) == 15, f'Original array must have 15 elements, but got {len(original_array)}'\nassert np.all((original_array >= -10) & (original_array <= 10)), 'Original array values must be between -10 and 10'\n\n# Test that positive_values contains only positive values from original array\nexpected_positive = original_array[original_array > 0]\nassert np.array_equal(positive_values, expected_positive), f'Positive values should be {expected_positive}, but got {positive_values}'\n\n# Test that all values in positive_values are indeed positive\nassert np.all(positive_values > 0), 'All values in positive_values must be positive'"
    },
    {
      "name": "Linear algebra operations test",
      "version": "1.0.0",
      "description": "Test matrix multiplication and eigenvalue computation",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'matrix' in locals() or 'matrix' in globals(), 'Variable \"matrix\" must be defined'\nassert 'matrix_squared' in locals() or 'matrix_squared' in globals(), 'Variable \"matrix_squared\" must be defined'\nassert 'eigenvalues' in locals() or 'eigenvalues' in globals(), 'Variable \"eigenvalues\" must be defined'\n\n# Test that matrix is a 3x3 numpy array\nassert isinstance(matrix, np.ndarray), 'Variable \"matrix\" must be a numpy array'\nassert matrix.shape == (3, 3), f'Matrix must have shape (3, 3), but got {matrix.shape}'\nassert np.issubdtype(matrix.dtype, np.floating), 'Matrix must contain floating-point numbers'\nassert np.all((matrix >= 0) & (matrix <= 1)), 'Matrix values must be between 0 and 1'\n\n# Test matrix multiplication\nassert isinstance(matrix_squared, np.ndarray), 'Variable \"matrix_squared\" must be a numpy array'\nassert matrix_squared.shape == (3, 3), f'Matrix_squared must have shape (3, 3), but got {matrix_squared.shape}'\nexpected_squared = matrix @ matrix\nassert np.allclose(matrix_squared, expected_squared), 'Matrix_squared should be matrix @ matrix'\n\n# Test eigenvalues\nassert isinstance(eigenvalues, np.ndarray), 'Variable \"eigenvalues\" must be a numpy array'\nassert len(eigenvalues) == 3, f'Eigenvalues array must have 3 elements, but got {len(eigenvalues)}'\nexpected_eigenvalues = np.linalg.eigvals(matrix)\nassert np.allclose(np.sort(eigenvalues), np.sort(expected_eigenvalues)), 'Eigenvalues do not match expected values'"
    },
    {
      "name": "Statistical analysis test",
      "version": "1.0.0",
      "description": "Test comprehensive statistical calculations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'data' in locals() or 'data' in globals(), 'Variable \"data\" must be defined'\nassert 'col_means' in locals() or 'col_means' in globals(), 'Variable \"col_means\" must be defined'\nassert 'col_medians' in locals() or 'col_medians' in globals(), 'Variable \"col_medians\" must be defined'\nassert 'col_stds' in locals() or 'col_stds' in globals(), 'Variable \"col_stds\" must be defined'\nassert 'col_vars' in locals() or 'col_vars' in globals(), 'Variable \"col_vars\" must be defined'\n\n# Test data array properties\nassert isinstance(data, np.ndarray), 'Variable \"data\" must be a numpy array'\nassert data.shape == (4, 5), f'Data must have shape (4, 5), but got {data.shape}'\nassert np.all((data >= 1) & (data <= 100)), 'Data values must be between 1 and 100'\n\n# Test statistical arrays\nassert isinstance(col_means, np.ndarray), 'Variable \"col_means\" must be a numpy array'\nassert isinstance(col_medians, np.ndarray), 'Variable \"col_medians\" must be a numpy array'\nassert isinstance(col_stds, np.ndarray), 'Variable \"col_stds\" must be a numpy array'\nassert isinstance(col_vars, np.ndarray), 'Variable \"col_vars\" must be a numpy array'\n\n# Test array lengths\nassert len(col_means) == 5, f'col_means must have 5 elements (one per column), but got {len(col_means)}'\nassert len(col_medians) == 5, f'col_medians must have 5 elements (one per column), but got {len(col_medians)}'\nassert len(col_stds) == 5, f'col_stds must have 5 elements (one per column), but got {len(col_stds)}'\nassert len(col_vars) == 5, f'col_vars must have 5 elements (one per column), but got {len(col_vars)}'\n\n# Test that calculations are correct\nassert np.allclose(col_means, np.mean(data, axis=0)), 'Column means are incorrect'\nassert np.allclose(col_medians, np.median(data, axis=0)), 'Column medians are incorrect'\nassert np.allclose(col_stds, np.std(data, axis=0)), 'Column standard deviations are incorrect'\nassert np.allclose(col_vars, np.var(data, axis=0)), 'Column variances are incorrect'"
    },
    {
      "name": "Broadcasting and vectorization test",
      "version": "1.0.0",
      "description": "Test NumPy broadcasting operations",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'array_4x1' in locals() or 'array_4x1' in globals(), 'Variable \"array_4x1\" must be defined'\nassert 'array_1x3' in locals() or 'array_1x3' in globals(), 'Variable \"array_1x3\" must be defined'\nassert 'broadcasted_result' in locals() or 'broadcasted_result' in globals(), 'Variable \"broadcasted_result\" must be defined'\n\n# Test array shapes and values\nassert isinstance(array_4x1, np.ndarray), 'Variable \"array_4x1\" must be a numpy array'\nassert array_4x1.shape == (4, 1), f'Array_4x1 must have shape (4, 1), but got {array_4x1.shape}'\nassert np.array_equal(array_4x1.flatten(), [1, 2, 3, 4]), f'Array_4x1 should contain [1, 2, 3, 4], but got {array_4x1.flatten()}'\n\nassert isinstance(array_1x3, np.ndarray), 'Variable \"array_1x3\" must be a numpy array'\nassert array_1x3.shape == (1, 3), f'Array_1x3 must have shape (1, 3), but got {array_1x3.shape}'\nassert np.array_equal(array_1x3.flatten(), [10, 20, 30]), f'Array_1x3 should contain [10, 20, 30], but got {array_1x3.flatten()}'\n\n# Test broadcasting result\nassert isinstance(broadcasted_result, np.ndarray), 'Variable \"broadcasted_result\" must be a numpy array'\nassert broadcasted_result.shape == (4, 3), f'Broadcasted_result must have shape (4, 3), but got {broadcasted_result.shape}'\nexpected_result = array_4x1 + array_1x3\nassert np.array_equal(broadcasted_result, expected_result), f'Broadcasted result should be {expected_result}, but got {broadcasted_result}'"
    },
    {
      "name": "Advanced indexing and sorting test",
      "version": "1.0.0",
      "description": "Test advanced indexing and multi-dimensional sorting",
      "content": "import numpy as np\n\n# Test that required variables exist\nassert 'original_array' in locals() or 'original_array' in globals(), 'Variable \"original_array\" must be defined'\nassert 'sorted_rows' in locals() or 'sorted_rows' in globals(), 'Variable \"sorted_rows\" must be defined'\nassert 'flattened' in locals() or 'flattened' in globals(), 'Variable \"flattened\" must be defined'\nassert 'sort_indices' in locals() or 'sort_indices' in globals(), 'Variable \"sort_indices\" must be defined'\n\n# Test original array properties\nassert isinstance(original_array, np.ndarray), 'Variable \"original_array\" must be a numpy array'\nassert original_array.shape == (5, 3), f'Original array must have shape (5, 3), but got {original_array.shape}'\nassert np.all((original_array >= 0) & (original_array <= 50)), 'Original array values must be between 0 and 50'\n\n# Test sorted rows\nassert isinstance(sorted_rows, np.ndarray), 'Variable \"sorted_rows\" must be a numpy array'\nassert sorted_rows.shape == (5, 3), f'Sorted_rows must have shape (5, 3), but got {sorted_rows.shape}'\n# Check that each row is sorted in descending order\nfor i in range(5):\n    row_sorted = np.sort(original_array[i])[::-1]  # Sort descending\n    assert np.array_equal(sorted_rows[i], row_sorted), f'Row {i} is not sorted correctly in descending order'\n\n# Test flattened array\nassert isinstance(flattened, np.ndarray), 'Variable \"flattened\" must be a numpy array'\nassert flattened.shape == (15,), f'Flattened array must have shape (15,), but got {flattened.shape}'\nassert np.array_equal(flattened, original_array.flatten()), 'Flattened array should be the flattened version of original array'\n\n# Test sort indices\nassert isinstance(sort_indices, np.ndarray), 'Variable \"sort_indices\" must be a numpy array'\nassert len(sort_indices) == 15, f'Sort_indices must have 15 elements, but got {len(sort_indices)}'\nexpected_indices = np.argsort(flattened)\nassert np.array_equal(sort_indices, expected_indices), 'Sort indices are incorrect for flattened array'"
    }
  ]
}
